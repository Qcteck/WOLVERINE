const TRADERONE_DEPOSIT_KEYFILE = process.env.TRADERONE_DEPOSIT_KEYFILE || "/opt/traderone-opt/keys/traderone_deposit.json";
const USDC_MINT = process.env.USDC_MINT || "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
'use strict';

const express = require('express');
const http = require('http');
const path = require('path');

const { WebSocketServer } = require('ws');

const app = express();
app.use(express.json());



/* WOLVERINE_START_ROUTE_BEGIN */
const BOT_WALLET = process.env.TRADERONE_BOT_WALLET;
const MIN_SOL_FEES = Number(process.env.TRADERONE_MIN_SOL_FEES || "0.01");

// Valide que le BOT a assez de SOL (fees) + assez de USDC vs budget demandé
app.post("/wolverine/traderone/api/start", async (req, res) => {
  try {
    const { wallet, budget } = req.body || {};
    const b = Number(budget);

    if (!wallet || typeof wallet !== "string") return res.status(400).json({ ok:false, error:"bad_wallet" });
    if (!isFinite(b) || b <= 0) return res.status(400).json({ ok:false, error:"bad_budget" });
    if (!BOT_WALLET) return res.status(500).json({ ok:false, error:"bot_wallet_not_set" });

    // call balances2 for BOT
    const http = require("http");
    const url = "http://127.0.0.1:8585/wolverine/traderone/api/balances2?wallet=" + encodeURIComponent(BOT_WALLET);

    const raw = await new Promise((resolve, reject) => {
      http.get(url, (r) => {
        let buf = "";
        r.on("data", (c) => buf += c);
        r.on("end", () => resolve({ code: r.statusCode || 0, body: buf }));
      }).on("error", reject);
    });

    if (raw.code < 200 || raw.code >= 300) {
      return res.status(502).json({ ok:false, error:"balances2_failed", detail:String(raw.body).slice(0,200) });
    }

    let j;
    try { j = JSON.parse(raw.body); } catch(e) {
      return res.status(502).json({ ok:false, error:"balances2_bad_json", detail:String(raw.body).slice(0,120) });
    }

    // your balances2 schema: { user:{sol,usdc,...}, trader:{...} }
    const botSol  = Number(j?.user?.sol  ?? 0);
    const botUsdc = Number(j?.user?.usdc ?? 0);

    if (botSol < MIN_SOL_FEES) return res.status(400).json({ ok:false, error:"bot_needs_sol_fees", botSol, min: MIN_SOL_FEES });
    if (botUsdc < b) return res.status(400).json({ ok:false, error:"insufficient_usdc_on_bot", botUsdc, needed: b });

    return res.json({ ok:true, wallet, budget:b, botSol, botUsdc, msg:"start validated" });
  } catch (e) {
    return res.status(500).json({ ok:false, error:"start_failed", detail:String(e?.message || e) });
  }
});
/* WOLVERINE_START_ROUTE_END */




/* WOLVERINE_FORCE_ROUTE_BEGIN */
// Force /wolverine/traderone/api/balances2 to return same JSON as /api/balances2
app.get("/wolverine/traderone/api/balances2", (req, res) => {
  const http = require("http");
  const q = (req._parsedUrl && req._parsedUrl.search) ? req._parsedUrl.search : "";
  const opts = { hostname: "127.0.0.1", port: 8585, path: "/api/balances2" + q, method: "GET" };

  const r = http.request(opts, (p) => {
    res.statusCode = p.statusCode || 502;
    // copie headers utiles
    Object.entries(p.headers || {}).forEach(([k,v]) => { if (v !== undefined) res.setHeader(k, v); });
    p.pipe(res);
  });

  r.on("error", (e) => res.status(502).json({ ok:false, error:"proxy_failed", detail:String(e && e.message || e) }));
  r.end();
});
/* WOLVERINE_FORCE_ROUTE_END */

/* WOLVERINE_MAP_BEGIN */
// Map /wolverine/traderone/api/* -> /api/* (must be BEFORE routes)
app.use("/wolverine/traderone/api", (req, res, next) => {
  // req.url here is "/balances2?wallet=..." etc.
  req.url = "/api" + req.url;
  next();
});
/* WOLVERINE_MAP_END */

require("./proxy-traderone")(app);
app.disable('x-powered-by');
app.use(express.json({ limit: '2mb' }));


// WOLVERINE_REWRITE_BEGIN
app.use("/wolverine/traderone/api", (req, res, next) => {
  // ici req.url = "/balances2?wallet=..." => on préfixe /api
  req.url = "/api" + req.url;
  next();
});
// WOLVERINE_REWRITE_END
// ===== Static front (public/) =====
const PUBLIC_DIR = path.join(__dirname, 'public');
app.use('/', express.static(PUBLIC_DIR, { maxAge: '1h', etag: true }));

// ===== API =====
app.get('/health', (req, res) => res.status(200).send('ok'));

app.get('/api/health', (req, res) => {
  res.json({ ok: true, service: 'traderone', ts: new Date().toISOString() });
});

app.get('/api/status', (req, res) => {
  res.json({
    ok: true,
    mode: process.env.MODE || 'paper',
    network: process.env.NETWORK || 'solana',
    ts: new Date().toISOString()
  });
});

// Stubs (remplace par tes vraies fonctions)
app.post('/api/start', (req, res) => res.json({ ok: true, started: true, params: req.body || {} }));
app.post('/api/stop',  (req, res) => res.json({ ok: true, stopped: true }));
app.post('/api/swap',  (req, res) => res.json({ ok: true, simulated: true, request: req.body || {} }));

// SPA fallback
app.get(/^\/(?!api\/).*/, (req, res) => res.sendFile(path.join(PUBLIC_DIR, 'index.html')));

const HOST = process.env.HOST || '127.0.0.1';
const PORT = parseInt(process.env.PORT || '8585', 10);

const server = http.createServer(app);

// ===== WebSocket (optionnel) =====
const wss = new WebSocketServer({ server, path: '/ws' });
wss.on('connection', (ws) => {
  ws.send(JSON.stringify({ type: 'hello', ts: new Date().toISOString() }));
  ws.on('message', (msg) => {
    ws.send(JSON.stringify({ type: 'echo', msg: msg.toString() }));
  });
});

server.listen(PORT, HOST, () => {
  console.log(`[TraderOne] listening on http://${HOST}:${PORT}`);
});


// ===== WOLVERINE_BALANCES_API (server-side RPC, avoids browser CORS/403) =====
const SOLANA_RPCS = [
  "https://api.mainnet-beta.solana.com",
  "https://solana-mainnet.g.alchemy.com/v2/demo",
];

async function solanaRpc(method, params) {
  let lastErr = null;
  for (const url of SOLANA_RPCS) {
    try {
      const r = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ jsonrpc: "2.0", id: 1, method, params }),
      });
      const data = await r.json().catch(() => ({}));
      if (!r.ok || data.error) throw new Error((data.error && data.error.message) || ("HTTP " + r.status));
      return data.result;
    } catch (e) { lastErr = e; }
  }
  throw lastErr || new Error("RPC failed");
}

// GET /api/balances?wallet=PUBLICKEY
app.get("/api/balances", async (req, res) => {
  try {
    const wallet = String(req.query.wallet || "").trim();
    if (!wallet) return res.status(400).json({ error: "missing wallet" });

    const solRes = await solanaRpc("getBalance", [wallet]);
    const sol = (solRes && solRes.value ? (solRes.value / 1_000_000_000) : 0);

    const usdcMint = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
    const tokRes = await solanaRpc("getTokenAccountsByOwner", [
      wallet,
      { mint: usdcMint },
      { encoding: "jsonParsed" }
    ]);

    let usdc = 0;
    const v = (tokRes && tokRes.value) || [];
    if (v.length) {
      usdc = v[0]?.account?.data?.parsed?.info?.tokenAmount?.uiAmount ?? 0;
    }

    res.json({ wallet, sol, usdc });
  } catch (e) {
    res.status(500).json({ error: String(e && e.message ? e.message : e) });
  }
});
// ===== /WOLVERINE_BALANCES_API =====


/* WOLVERINE_BALANCES2_BEGIN */
(function(){
  try {
    // expose constants if not already defined globally
    const USDC_MINT_LOCAL = process.env.USDC_MINT || "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
    const TRADERONE_DEPOSIT_KEYFILE_LOCAL = process.env.TRADERONE_DEPOSIT_KEYFILE || "/opt/traderone-opt/keys/traderone_deposit.json";

    const fs = require("fs");
    const { PublicKey, Keypair } = require("@solana/web3.js");

/* WOLVERINE_CONN_BEGIN */
let solanaWeb3;
try { solanaWeb3 = require("@solana/web3.js"); } catch(e) { solanaWeb3 = null; }
const SOLANA_RPC = process.env.SOLANA_RPC || (solanaWeb3?.clusterApiUrl ? solanaWeb3.clusterApiUrl("mainnet-beta") : "https://api.mainnet-beta.solana.com");
const connection = solanaWeb3 ? new solanaWeb3.Connection(SOLANA_RPC, "confirmed") : null;
/* WOLVERINE_CONN_END */


    function loadTraderOneKeypair() {
      const secret = Uint8Array.from(JSON.parse(fs.readFileSync(TRADERONE_DEPOSIT_KEYFILE_LOCAL, "utf8")));
      return Keypair.fromSecretKey(secret);
    }

    async function getUsdcSum(ownerPk) {
      const tokRes = await connection.getParsedTokenAccountsByOwner(
        ownerPk,
        { mint: new PublicKey(USDC_MINT_LOCAL) },
        "confirmed"
      );
      let usdc = 0;
      for (const a of (tokRes.value || [])) {
        const ui = a?.account?.data?.parsed?.info?.tokenAmount?.uiAmount;
        const amtStr = a?.account?.data?.parsed?.info?.tokenAmount?.amount;
        const dec = a?.account?.data?.parsed?.info?.tokenAmount?.decimals ?? 6;
        if (ui !== null && ui !== undefined) usdc += Number(ui) || 0;
        else if (amtStr) usdc += (Number(amtStr) || 0) / (10 ** dec);
      }
      return { usdc, accounts: (tokRes.value || []).length };
    }

    // IMPORTANT: app + connection must already exist in your server.js
    
/* WOLVERINE_ALIAS_BALANCES2_BEGIN */
app.get("/wolverine/traderone/api/balances2", (req, res, next) => {
  // forward to the same handler as /api/balances2 by rewriting url + calling next()
  req.url = "/api/balances2" + (req._parsedUrl?.search || "");
  next();
});
/* WOLVERINE_ALIAS_BALANCES2_END */

app.get("/api/balances2", async (req, res) => {
      try {
        const wallet = (req.query.wallet || "").toString().trim();
        if (!wallet) return res.status(400).json({ error: "wallet missing" });

        const userPk = new PublicKey(wallet);
        const traderKp = loadTraderOneKeypair();
        const traderPk = traderKp.publicKey;

        const [userLam, traderLam] = await Promise.all([
          connection.getBalance(userPk, "confirmed"),
          connection.getBalance(traderPk, "confirmed"),
        ]);

        const [userU, traderU] = await Promise.all([
          getUsdcSum(userPk),
          getUsdcSum(traderPk),
        ]);

        return res.json({
          user:   { sol: userLam / 1e9,   usdc: userU.usdc,   usdcAccounts: userU.accounts },
          trader: { sol: traderLam / 1e9, usdc: traderU.usdc, usdcAccounts: traderU.accounts },
          traderWallet: traderPk.toBase58(),
          usdcMint: USDC_MINT_LOCAL
        });
      } catch (e) {
        return res.status(500).json({ error: e?.message || String(e) });
      }
    });

    console.log("[WOLVERINE] balances2 route ready");
  } catch (e) {
    console.log("[WOLVERINE] balances2 init error:", e?.message || String(e));
  }
})();
/* WOLVERINE_BALANCES2_END */



/* WOLVERINE_START_PUBLIC_VALIDATE_BEGIN */

// START public: valide que le bot wallet a assez de SOL (fees) + USDC (budget).
// NOTE: version "juste milieu" (ne prouve pas encore quel user a envoyé). Étape suivante = signature ou scan tx.
const BOT_WALLET = process.env.TRADERONE_BOT_WALLET || "PUT_BOT_WALLET_HERE";
const MIN_SOL_FEES = Number(process.env.TRADERONE_MIN_SOL_FEES || "0.01"); // ajustable
// budget = USDC demandé

app.post("/wolverine/traderone/api/start", async (req, res) => {
  try {
    const { wallet, budget } = req.body || {};
    const b = Number(budget);

    if (!wallet || typeof wallet !== "string") return res.status(400).json({ ok:false, error:"bad_wallet" });
    if (!isFinite(b) || b <= 0) return res.status(400).json({ ok:false, error:"bad_budget" });
    if (!BOT_WALLET || BOT_WALLET.includes("PUT_BOT_WALLET_HERE")) {
      return res.status(500).json({ ok:false, error:"bot_wallet_not_set" });
    }

    // appelle balances2 pour le BOT (même endpoint que ton front)
    const url = "http://127.0.0.1:8585/wolverine/traderone/api/balances2?wallet=" + encodeURIComponent(BOT_WALLET);
    const http = require("http");
    const data = await new Promise((resolve, reject) => {
      http.get(url, (r) => {
        let buf = "";
        r.on("data", (c) => (buf += c));
        r.on("end", () => resolve({ code: r.statusCode || 0, body: buf }));
      }).on("error", reject);
    });

    if (data.code < 200 || data.code >= 300) {
      return res.status(502).json({ ok:false, error:"balances2_failed", detail:String(data.body).slice(0,200) });
    }

    let j;
    try { j = JSON.parse(data.body); } catch(e) {
      return res.status(502).json({ ok:false, error:"balances2_bad_json", detail:String(data.body).slice(0,120) });
    }

    // adapte ici selon ton JSON réel:
    const botSol  = Number(j?.user?.sol  ?? j?.sol  ?? 0);
    const botUsdc = Number(j?.user?.usdc ?? j?.usdc ?? 0);

    if (!isFinite(botSol) || !isFinite(botUsdc)) {
      return res.status(502).json({ ok:false, error:"balances2_schema_unknown", got:j });
    }

    if (botSol < MIN_SOL_FEES) {
      return res.status(400).json({ ok:false, error:"bot_needs_sol_fees", botSol, min: MIN_SOL_FEES });
    }
    if (botUsdc < b) {
      return res.status(400).json({ ok:false, error:"insufficient_usdc_on_bot", botUsdc, needed: b });
    }

    // OK: on accepte (ici tu peux enregistrer wallet dans une liste "active")
    return res.json({ ok:true, wallet, budget:b, botSol, botUsdc, msg:"start validated" });
  } catch (e) {
    return res.status(500).json({ ok:false, error:"start_failed", detail:String(e?.message || e) });
  }
});

/* WOLVERINE_START_PUBLIC_VALIDATE_END */
